CeloModuleX ‚Äî Module Blueprint & Integration Guide

Standard Operating Procedure for Adding New Modules

üü¶ 1. MODULE BLUEPRINT PREPARATION (Required Before Coding)

Before developing any new module, the following Module Blueprint MUST be prepared.

This blueprint is generated by ChatGPT, not manually.

‚úî 1.1. Module Blueprint Format

Every module must be defined using this template:

ModuleName: (module name)
Category: (category name)
ModuleID: (next available ID)
Premium: (true/false)
Description: (what the module does)
Inputs: (user inputs or "none")
Outputs: (result produced by the module)
Event: ModuleAction
Version: 1

Important Note

The module blueprint is the most important input for Codex.
Without a blueprint, Codex cannot generate a valid module.

üüß 2. MODULE CONTRACT GENERATION (Codex)

After the blueprint is ready, give it to Codex with this instruction:

‚ÄúCodex, generate a Jello/CeloModuleX-compatible module contract based on this blueprint.‚Äù

Codex will write a contract that MUST contain:

execute()

getModuleInfo()

supportsFeature()

constructor(mainHubAddress, moduleID)

mainHub.recordUsage(msg.sender, moduleID)

Codex will always follow the Module Template Specification.

üü© 3. CONTRACT DEPLOYMENT (Remix or Script)

Once Codex provides the module contract:

‚úî 3.1. Compile Settings

Compiler: 0.8.24

Optimization: Enabled

‚úî 3.2. Deploy Parameters
constructor:
- mainHubAddress ‚Üí Your deployed MainHub.sol address
- moduleID ‚Üí Next module ID (e.g., 51, 52, 53‚Ä¶)


After deployment:

You get moduleAddress

Keep it safe for registerModule()

üü• 4. REGISTERING THE MODULE (Mandatory Step)

This is the most critical step.

Without registration:
‚ùå executeModule does NOT work
‚ùå stats do NOT update
‚ùå module does NOT appear in the UI
‚ùå fee system does NOT work
‚ùå events do NOT sync

‚úî 4.1. Call registerModule()
registerModule(
   moduleAddress,
   categoryID,
   moduleType,
   isPremium,
   version
);


This will officially add the module to CeloModuleX.

üü¶ 5. FRONTEND INTEGRATION (constants.js)

To display the module in the frontend, add one entry in:

üìå constants.js ‚Üí MODULES

MODULES[ModuleID] = {
  name: "ModuleName",
  category: "CategoryName",
  type: "module",
  premium: true/false,
  address: "0xModuleAddress"
}


After this step:

Modules Page shows the new module

Module Detail Page opens

executeModule works correctly

üüß 6. QA / TESTING CHECKLIST

After adding a module, perform all tests:

‚úî 6.1. executeModule Test

MetaMask opens ‚Üí user signs

Transaction completes

Fee is charged correctly

ModuleAction event is emitted

‚úî 6.2. Stats Update Test

Check MainHub:

totalActions increases

moduleActions[moduleID] increases

globalStats increases

uniqueModulesUsed updates (if applicable)

Score recalculates

‚úî 6.3. UI Test

Module appears in list

ModuleDetail page loads

executeModule works end-to-end

üü© 7. VERSIONING SYSTEM

When releasing a new module version:

version = oldVersion + 1


If the old version should be disabled:

deactivateModule(moduleID)


Module registry in MainHub keeps full version history.

üüß 8. FULL MODULE ADDING WORKFLOW (8-STEP SUMMARY)

This is the mandatory sequence for every new module:

1) Prepare Blueprint (from ChatGPT)
2) Give blueprint to Codex ‚Üí generate contract
3) Create module file in Remix
4) Paste full contract code
5) Deploy (mainHubAddress + moduleID)
6) registerModule() to MainHub
7) Add module to constants.js
8) Test executeModule + stats + UI

This 8-step workflow guarantees:

Unlimited scalability

Safe expansion to 1000+ modules

100% MainHub compatibility

Perfect synchronization for stats, fees, access control

No breaking changes

üü¶ FINAL STATEMENT

This document is:

Fully professional

Audit-ready

Developer-friendly

100% complete

Suitable for Codex, Cursor, and future team members

This should be included in your official development documentation.
